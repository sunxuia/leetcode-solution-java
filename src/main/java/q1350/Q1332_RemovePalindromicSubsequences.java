package q1350;

import org.junit.runner.RunWith;
import util.runner.Answer;
import util.runner.LeetCodeRunner;
import util.runner.TestData;
import util.runner.data.DataExpectation;

/**
 * [Easy] 1332. Remove Palindromic Subsequences
 * https://leetcode.com/problems/remove-palindromic-subsequences/
 *
 * Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence
 * from s.
 *
 * Return the minimum number of steps to make the given string empty.
 *
 * A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without
 * changing its order.
 *
 * A string is called palindrome if is one that reads the same backward as well as forward.
 *
 * Example 1:
 *
 * Input: s = "ababa"
 * Output: 1
 * Explanation: String is already palindrome
 *
 * Example 2:
 *
 * Input: s = "abb"
 * Output: 2
 * Explanation: "abb" -> "bb" -> "".
 * Remove palindromic subsequence "a" then "bb".
 *
 * Example 3:
 *
 * Input: s = "baabb"
 * Output: 2
 * Explanation: "baabb" -> "b" -> "".
 * Remove palindromic subsequence "baab" then "b".
 *
 * Example 4:
 *
 * Input: s = ""
 * Output: 0
 *
 * Constraints:
 *
 * 0 <= s.length <= 1000
 * s only consists of letters 'a' and 'b'
 *
 * 题解: 注意这里子字符串中的字符不要求是连续的, 只要字符之间保持相对顺序即可.
 */
@RunWith(LeetCodeRunner.class)
public class Q1332_RemovePalindromicSubsequences {

    @Answer
    public int removePalindromeSub(String s) {
        if (s.length() == 0) {
            return 0;
        }
        boolean a = false, b = false, palindromic = true;
        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
            char ci = s.charAt(i), cj = s.charAt(j);
            a |= ci == 'a' || cj == 'a';
            b |= ci == 'b' || cj == 'b';
            palindromic &= ci == cj;
        }
        return palindromic || (a ^ b) ? 1 : 2;
    }

    @TestData
    public DataExpectation example1 = DataExpectation.create("ababa").expect(1);

    @TestData
    public DataExpectation example2 = DataExpectation.create("abb").expect(2);

    @TestData
    public DataExpectation example3 = DataExpectation.create("baabb").expect(2);

    @TestData
    public DataExpectation example4 = DataExpectation.create("").expect(0);

    @TestData
    public DataExpectation normal1 = DataExpectation.create("bbaabaaa").expect(2);

}
